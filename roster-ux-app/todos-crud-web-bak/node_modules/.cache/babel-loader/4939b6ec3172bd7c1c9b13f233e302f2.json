{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.KeyPairEd25519 = exports.KeyPair = exports.PublicKey = exports.KeyType = void 0;\n\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\n\nconst serialize_1 = require(\"./serialize\");\n\nconst enums_1 = require(\"./enums\");\n/** All supported key types */\n\n\nvar KeyType;\n\n(function (KeyType) {\n  KeyType[KeyType[\"ED25519\"] = 0] = \"ED25519\";\n})(KeyType = exports.KeyType || (exports.KeyType = {}));\n\nfunction key_type_to_str(keyType) {\n  switch (keyType) {\n    case KeyType.ED25519:\n      return 'ed25519';\n\n    default:\n      throw new Error(`Unknown key type ${keyType}`);\n  }\n}\n\nfunction str_to_key_type(keyType) {\n  switch (keyType.toLowerCase()) {\n    case 'ed25519':\n      return KeyType.ED25519;\n\n    default:\n      throw new Error(`Unknown key type ${keyType}`);\n  }\n}\n/**\n * PublicKey representation that has type and bytes of the key.\n */\n\n\nclass PublicKey extends enums_1.Assignable {\n  static from(value) {\n    if (typeof value === 'string') {\n      return PublicKey.fromString(value);\n    }\n\n    return value;\n  }\n\n  static fromString(encodedKey) {\n    const parts = encodedKey.split(':');\n\n    if (parts.length === 1) {\n      return new PublicKey({\n        keyType: KeyType.ED25519,\n        data: serialize_1.base_decode(parts[0])\n      });\n    } else if (parts.length === 2) {\n      return new PublicKey({\n        keyType: str_to_key_type(parts[0]),\n        data: serialize_1.base_decode(parts[1])\n      });\n    } else {\n      throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n    }\n  }\n\n  toString() {\n    return `${key_type_to_str(this.keyType)}:${serialize_1.base_encode(this.data)}`;\n  }\n\n}\n\nexports.PublicKey = PublicKey;\n\nclass KeyPair {\n  /**\n   * @param curve Name of elliptical curve, case-insensitive\n   * @returns Random KeyPair based on the curve\n   */\n  static fromRandom(curve) {\n    switch (curve.toUpperCase()) {\n      case 'ED25519':\n        return KeyPairEd25519.fromRandom();\n\n      default:\n        throw new Error(`Unknown curve ${curve}`);\n    }\n  }\n\n  static fromString(encodedKey) {\n    const parts = encodedKey.split(':');\n\n    if (parts.length === 1) {\n      return new KeyPairEd25519(parts[0]);\n    } else if (parts.length === 2) {\n      switch (parts[0].toUpperCase()) {\n        case 'ED25519':\n          return new KeyPairEd25519(parts[1]);\n\n        default:\n          throw new Error(`Unknown curve: ${parts[0]}`);\n      }\n    } else {\n      throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n    }\n  }\n\n}\n\nexports.KeyPair = KeyPair;\n/**\n * This class provides key pair functionality for Ed25519 curve:\n * generating key pairs, encoding key pairs, signing and verifying.\n */\n\nclass KeyPairEd25519 extends KeyPair {\n  /**\n   * Construct an instance of key pair given a secret key.\n   * It's generally assumed that these are encoded in base58.\n   * @param {string} secretKey\n   */\n  constructor(secretKey) {\n    super();\n    const keyPair = tweetnacl_1.default.sign.keyPair.fromSecretKey(serialize_1.base_decode(secretKey));\n    this.publicKey = new PublicKey({\n      keyType: KeyType.ED25519,\n      data: keyPair.publicKey\n    });\n    this.secretKey = secretKey;\n  }\n  /**\n   * Generate a new random keypair.\n   * @example\n   * const keyRandom = KeyPair.fromRandom();\n   * keyRandom.publicKey\n   * // returns [PUBLIC_KEY]\n   *\n   * keyRandom.secretKey\n   * // returns [SECRET_KEY]\n   */\n\n\n  static fromRandom() {\n    const newKeyPair = tweetnacl_1.default.sign.keyPair();\n    return new KeyPairEd25519(serialize_1.base_encode(newKeyPair.secretKey));\n  }\n\n  sign(message) {\n    const signature = tweetnacl_1.default.sign.detached(message, serialize_1.base_decode(this.secretKey));\n    return {\n      signature,\n      publicKey: this.publicKey\n    };\n  }\n\n  verify(message, signature) {\n    return tweetnacl_1.default.sign.detached.verify(message, signature, this.publicKey.data);\n  }\n\n  toString() {\n    return `ed25519:${this.secretKey}`;\n  }\n\n  getPublicKey() {\n    return this.publicKey;\n  }\n\n}\n\nexports.KeyPairEd25519 = KeyPairEd25519;","map":{"version":3,"sources":["/home/jjsullivan/near-roster-ux-project/roster-ux-app/todos-crud-web-bak/node_modules/near-api-js/lib/utils/key_pair.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","KeyPairEd25519","KeyPair","PublicKey","KeyType","tweetnacl_1","require","serialize_1","enums_1","key_type_to_str","keyType","ED25519","Error","str_to_key_type","toLowerCase","Assignable","from","fromString","encodedKey","parts","split","length","data","base_decode","toString","base_encode","fromRandom","curve","toUpperCase","constructor","secretKey","keyPair","default","sign","fromSecretKey","publicKey","newKeyPair","message","signature","detached","verify","getPublicKey"],"mappings":"AAAA;;AACA,IAAIA,eAAe,GAAI,QAAQ,KAAKA,eAAd,IAAkC,UAAUC,GAAV,EAAe;AACnE,SAAQA,GAAG,IAAIA,GAAG,CAACC,UAAZ,GAA0BD,GAA1B,GAAgC;AAAE,eAAWA;AAAb,GAAvC;AACH,CAFD;;AAGAE,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,cAAR,GAAyBF,OAAO,CAACG,OAAR,GAAkBH,OAAO,CAACI,SAAR,GAAoBJ,OAAO,CAACK,OAAR,GAAkB,KAAK,CAAtF;;AACA,MAAMC,WAAW,GAAGX,eAAe,CAACY,OAAO,CAAC,WAAD,CAAR,CAAnC;;AACA,MAAMC,WAAW,GAAGD,OAAO,CAAC,aAAD,CAA3B;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,SAAD,CAAvB;AACA;;;AACA,IAAIF,OAAJ;;AACA,CAAC,UAAUA,OAAV,EAAmB;AAChBA,EAAAA,OAAO,CAACA,OAAO,CAAC,SAAD,CAAP,GAAqB,CAAtB,CAAP,GAAkC,SAAlC;AACH,CAFD,EAEGA,OAAO,GAAGL,OAAO,CAACK,OAAR,KAAoBL,OAAO,CAACK,OAAR,GAAkB,EAAtC,CAFb;;AAGA,SAASK,eAAT,CAAyBC,OAAzB,EAAkC;AAC9B,UAAQA,OAAR;AACI,SAAKN,OAAO,CAACO,OAAb;AAAsB,aAAO,SAAP;;AACtB;AAAS,YAAM,IAAIC,KAAJ,CAAW,oBAAmBF,OAAQ,EAAtC,CAAN;AAFb;AAIH;;AACD,SAASG,eAAT,CAAyBH,OAAzB,EAAkC;AAC9B,UAAQA,OAAO,CAACI,WAAR,EAAR;AACI,SAAK,SAAL;AAAgB,aAAOV,OAAO,CAACO,OAAf;;AAChB;AAAS,YAAM,IAAIC,KAAJ,CAAW,oBAAmBF,OAAQ,EAAtC,CAAN;AAFb;AAIH;AACD;AACA;AACA;;;AACA,MAAMP,SAAN,SAAwBK,OAAO,CAACO,UAAhC,CAA2C;AAC5B,SAAJC,IAAI,CAAChB,KAAD,EAAQ;AACf,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC3B,aAAOG,SAAS,CAACc,UAAV,CAAqBjB,KAArB,CAAP;AACH;;AACD,WAAOA,KAAP;AACH;;AACgB,SAAViB,UAAU,CAACC,UAAD,EAAa;AAC1B,UAAMC,KAAK,GAAGD,UAAU,CAACE,KAAX,CAAiB,GAAjB,CAAd;;AACA,QAAID,KAAK,CAACE,MAAN,KAAiB,CAArB,EAAwB;AACpB,aAAO,IAAIlB,SAAJ,CAAc;AAAEO,QAAAA,OAAO,EAAEN,OAAO,CAACO,OAAnB;AAA4BW,QAAAA,IAAI,EAAEf,WAAW,CAACgB,WAAZ,CAAwBJ,KAAK,CAAC,CAAD,CAA7B;AAAlC,OAAd,CAAP;AACH,KAFD,MAGK,IAAIA,KAAK,CAACE,MAAN,KAAiB,CAArB,EAAwB;AACzB,aAAO,IAAIlB,SAAJ,CAAc;AAAEO,QAAAA,OAAO,EAAEG,eAAe,CAACM,KAAK,CAAC,CAAD,CAAN,CAA1B;AAAsCG,QAAAA,IAAI,EAAEf,WAAW,CAACgB,WAAZ,CAAwBJ,KAAK,CAAC,CAAD,CAA7B;AAA5C,OAAd,CAAP;AACH,KAFI,MAGA;AACD,YAAM,IAAIP,KAAJ,CAAU,2DAAV,CAAN;AACH;AACJ;;AACDY,EAAAA,QAAQ,GAAG;AACP,WAAQ,GAAEf,eAAe,CAAC,KAAKC,OAAN,CAAe,IAAGH,WAAW,CAACkB,WAAZ,CAAwB,KAAKH,IAA7B,CAAmC,EAA9E;AACH;;AArBsC;;AAuB3CvB,OAAO,CAACI,SAAR,GAAoBA,SAApB;;AACA,MAAMD,OAAN,CAAc;AACV;AACJ;AACA;AACA;AACqB,SAAVwB,UAAU,CAACC,KAAD,EAAQ;AACrB,YAAQA,KAAK,CAACC,WAAN,EAAR;AACI,WAAK,SAAL;AAAgB,eAAO3B,cAAc,CAACyB,UAAf,EAAP;;AAChB;AAAS,cAAM,IAAId,KAAJ,CAAW,iBAAgBe,KAAM,EAAjC,CAAN;AAFb;AAIH;;AACgB,SAAVV,UAAU,CAACC,UAAD,EAAa;AAC1B,UAAMC,KAAK,GAAGD,UAAU,CAACE,KAAX,CAAiB,GAAjB,CAAd;;AACA,QAAID,KAAK,CAACE,MAAN,KAAiB,CAArB,EAAwB;AACpB,aAAO,IAAIpB,cAAJ,CAAmBkB,KAAK,CAAC,CAAD,CAAxB,CAAP;AACH,KAFD,MAGK,IAAIA,KAAK,CAACE,MAAN,KAAiB,CAArB,EAAwB;AACzB,cAAQF,KAAK,CAAC,CAAD,CAAL,CAASS,WAAT,EAAR;AACI,aAAK,SAAL;AAAgB,iBAAO,IAAI3B,cAAJ,CAAmBkB,KAAK,CAAC,CAAD,CAAxB,CAAP;;AAChB;AAAS,gBAAM,IAAIP,KAAJ,CAAW,kBAAiBO,KAAK,CAAC,CAAD,CAAI,EAArC,CAAN;AAFb;AAIH,KALI,MAMA;AACD,YAAM,IAAIP,KAAJ,CAAU,2DAAV,CAAN;AACH;AACJ;;AAzBS;;AA2Bdb,OAAO,CAACG,OAAR,GAAkBA,OAAlB;AACA;AACA;AACA;AACA;;AACA,MAAMD,cAAN,SAA6BC,OAA7B,CAAqC;AACjC;AACJ;AACA;AACA;AACA;AACI2B,EAAAA,WAAW,CAACC,SAAD,EAAY;AACnB;AACA,UAAMC,OAAO,GAAG1B,WAAW,CAAC2B,OAAZ,CAAoBC,IAApB,CAAyBF,OAAzB,CAAiCG,aAAjC,CAA+C3B,WAAW,CAACgB,WAAZ,CAAwBO,SAAxB,CAA/C,CAAhB;AACA,SAAKK,SAAL,GAAiB,IAAIhC,SAAJ,CAAc;AAAEO,MAAAA,OAAO,EAAEN,OAAO,CAACO,OAAnB;AAA4BW,MAAAA,IAAI,EAAES,OAAO,CAACI;AAA1C,KAAd,CAAjB;AACA,SAAKL,SAAL,GAAiBA,SAAjB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACqB,SAAVJ,UAAU,GAAG;AAChB,UAAMU,UAAU,GAAG/B,WAAW,CAAC2B,OAAZ,CAAoBC,IAApB,CAAyBF,OAAzB,EAAnB;AACA,WAAO,IAAI9B,cAAJ,CAAmBM,WAAW,CAACkB,WAAZ,CAAwBW,UAAU,CAACN,SAAnC,CAAnB,CAAP;AACH;;AACDG,EAAAA,IAAI,CAACI,OAAD,EAAU;AACV,UAAMC,SAAS,GAAGjC,WAAW,CAAC2B,OAAZ,CAAoBC,IAApB,CAAyBM,QAAzB,CAAkCF,OAAlC,EAA2C9B,WAAW,CAACgB,WAAZ,CAAwB,KAAKO,SAA7B,CAA3C,CAAlB;AACA,WAAO;AAAEQ,MAAAA,SAAF;AAAaH,MAAAA,SAAS,EAAE,KAAKA;AAA7B,KAAP;AACH;;AACDK,EAAAA,MAAM,CAACH,OAAD,EAAUC,SAAV,EAAqB;AACvB,WAAOjC,WAAW,CAAC2B,OAAZ,CAAoBC,IAApB,CAAyBM,QAAzB,CAAkCC,MAAlC,CAAyCH,OAAzC,EAAkDC,SAAlD,EAA6D,KAAKH,SAAL,CAAeb,IAA5E,CAAP;AACH;;AACDE,EAAAA,QAAQ,GAAG;AACP,WAAQ,WAAU,KAAKM,SAAU,EAAjC;AACH;;AACDW,EAAAA,YAAY,GAAG;AACX,WAAO,KAAKN,SAAZ;AACH;;AAtCgC;;AAwCrCpC,OAAO,CAACE,cAAR,GAAyBA,cAAzB","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.KeyPairEd25519 = exports.KeyPair = exports.PublicKey = exports.KeyType = void 0;\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\nconst serialize_1 = require(\"./serialize\");\nconst enums_1 = require(\"./enums\");\n/** All supported key types */\nvar KeyType;\n(function (KeyType) {\n    KeyType[KeyType[\"ED25519\"] = 0] = \"ED25519\";\n})(KeyType = exports.KeyType || (exports.KeyType = {}));\nfunction key_type_to_str(keyType) {\n    switch (keyType) {\n        case KeyType.ED25519: return 'ed25519';\n        default: throw new Error(`Unknown key type ${keyType}`);\n    }\n}\nfunction str_to_key_type(keyType) {\n    switch (keyType.toLowerCase()) {\n        case 'ed25519': return KeyType.ED25519;\n        default: throw new Error(`Unknown key type ${keyType}`);\n    }\n}\n/**\n * PublicKey representation that has type and bytes of the key.\n */\nclass PublicKey extends enums_1.Assignable {\n    static from(value) {\n        if (typeof value === 'string') {\n            return PublicKey.fromString(value);\n        }\n        return value;\n    }\n    static fromString(encodedKey) {\n        const parts = encodedKey.split(':');\n        if (parts.length === 1) {\n            return new PublicKey({ keyType: KeyType.ED25519, data: serialize_1.base_decode(parts[0]) });\n        }\n        else if (parts.length === 2) {\n            return new PublicKey({ keyType: str_to_key_type(parts[0]), data: serialize_1.base_decode(parts[1]) });\n        }\n        else {\n            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n        }\n    }\n    toString() {\n        return `${key_type_to_str(this.keyType)}:${serialize_1.base_encode(this.data)}`;\n    }\n}\nexports.PublicKey = PublicKey;\nclass KeyPair {\n    /**\n     * @param curve Name of elliptical curve, case-insensitive\n     * @returns Random KeyPair based on the curve\n     */\n    static fromRandom(curve) {\n        switch (curve.toUpperCase()) {\n            case 'ED25519': return KeyPairEd25519.fromRandom();\n            default: throw new Error(`Unknown curve ${curve}`);\n        }\n    }\n    static fromString(encodedKey) {\n        const parts = encodedKey.split(':');\n        if (parts.length === 1) {\n            return new KeyPairEd25519(parts[0]);\n        }\n        else if (parts.length === 2) {\n            switch (parts[0].toUpperCase()) {\n                case 'ED25519': return new KeyPairEd25519(parts[1]);\n                default: throw new Error(`Unknown curve: ${parts[0]}`);\n            }\n        }\n        else {\n            throw new Error('Invalid encoded key format, must be <curve>:<encoded key>');\n        }\n    }\n}\nexports.KeyPair = KeyPair;\n/**\n * This class provides key pair functionality for Ed25519 curve:\n * generating key pairs, encoding key pairs, signing and verifying.\n */\nclass KeyPairEd25519 extends KeyPair {\n    /**\n     * Construct an instance of key pair given a secret key.\n     * It's generally assumed that these are encoded in base58.\n     * @param {string} secretKey\n     */\n    constructor(secretKey) {\n        super();\n        const keyPair = tweetnacl_1.default.sign.keyPair.fromSecretKey(serialize_1.base_decode(secretKey));\n        this.publicKey = new PublicKey({ keyType: KeyType.ED25519, data: keyPair.publicKey });\n        this.secretKey = secretKey;\n    }\n    /**\n     * Generate a new random keypair.\n     * @example\n     * const keyRandom = KeyPair.fromRandom();\n     * keyRandom.publicKey\n     * // returns [PUBLIC_KEY]\n     *\n     * keyRandom.secretKey\n     * // returns [SECRET_KEY]\n     */\n    static fromRandom() {\n        const newKeyPair = tweetnacl_1.default.sign.keyPair();\n        return new KeyPairEd25519(serialize_1.base_encode(newKeyPair.secretKey));\n    }\n    sign(message) {\n        const signature = tweetnacl_1.default.sign.detached(message, serialize_1.base_decode(this.secretKey));\n        return { signature, publicKey: this.publicKey };\n    }\n    verify(message, signature) {\n        return tweetnacl_1.default.sign.detached.verify(message, signature, this.publicKey.data);\n    }\n    toString() {\n        return `ed25519:${this.secretKey}`;\n    }\n    getPublicKey() {\n        return this.publicKey;\n    }\n}\nexports.KeyPairEd25519 = KeyPairEd25519;\n"]},"metadata":{},"sourceType":"script"}